---
description: how to implement new test code 
alwaysApply: false
---

## Principles

STARTER_CHARACTER for generating tests = üîç

1. **Write tests before production code**
   - Define or extend tests that express the desired behaviour and edge cases.
   - Only then implement or change production code.

2. **Align on test cases first**
   - Discuss and agree test scenarios (including edge cases) before implementation.
   - Treat tests as the primary executable specification.

3. **Make tests fail meaningfully first**
   - Prefer failures where the code is implemented but *wrong* (e.g. incorrect return values), so the failing assertions describe behavioural gaps rather than "not implemented" errors.

4. **Work in small, focused steps**
   - Change one small, coherent piece of behaviour at a time.
   - Keep each test or code change narrowly scoped and immediately verifiable.
   - **NEVER create large commits** with many production classes at once. Each production class with logic should have its test committed together.

5. **Avoid magic literals in tests**
   - When a value is used repeatedly in a test suite, define it once as a `const` and reuse it.
   - This reduces duplication and keeps tests readable and maintainable.

6. **Avoid brittle implementation-detail expectations**
   - Prefer assertions about *observable behaviour* and final outputs.
   - Only assert on implementation details (like mock call counts) when the *behaviour* depends on them.

7. **Split tests by concern**
   - Place each logical group of tests in a separate file or nested class.
   - Use `@Nested` classes for logical grouping within a test file.

## Test Classification (Naming Convention)

This project follows the **Maven Surefire/Failsafe convention** for separating test types:

| Type | File Pattern | Speed | Dependencies | Mill Command |
|------|--------------|-------|--------------|--------------|
| **Unit Tests** | `*Test.java` | Fast (<1s) | Mocked | `mill test.testForked` |
| **Integration Tests** | `*IT.java` | Slow (10-30s) | Real (DB, network) | `mill itest.testForked` |

### Unit Tests (`*Test.java`)
- Use **mocks** for all external dependencies (database, network, etc.)
- Run in milliseconds without Docker or external services
- Test business logic in isolation
- Example: `IngestionServiceTest.java`

```java
// Unit test - uses mocks, runs fast
@DisplayName("IngestionService")
class IngestionServiceTest {
    @Test
    void ingestsBook() {
        VectorStore mockVectorStore = mock(VectorStore.class);
        // ... mock setup and assertions
    }
}
```

### Integration Tests (`*IT.java`)
- Use **real dependencies** (Testcontainers, network calls)
- Require Docker for database containers
- Test full integration with external systems
- Example: `IngestionServiceIT.java`

```java
// Integration test - uses real DB, runs slower
@SpringBootTest
@Testcontainers
@ActiveProfiles("test")
class IngestionServiceIT {
    @Container
    @ServiceConnection
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(...);
    
    @Autowired
    private IngestionService ingestionService;
}
```

## Running Tests

```bash
# Unit tests only (fast, run frequently during development)
mill test.testForked

# Integration tests only (slow, run before commit)
mill itest.testForked

# Run specific test class
mill test.testOnly 'de.bas.bodo.genai.ingestion.IngestionServiceTest'

# Run all tests with coverage
mill test.testForked && mill itest.testForked
mill de.tobiasroeser.mill.jacoco.Jacoco/jacocoReportFull

# Coverage shortcut
./coverage.sh
```

## Test Coverage

- Coverage is collected via **JaCoCo** (mill-jacoco plugin)
- Both unit and integration tests contribute to coverage
- View coverage in VS Code/Cursor with **Coverage Gutters** extension
- Generate HTML report: `mill de.tobiasroeser.mill.jacoco.Jacoco/jacocoReportFull`

### Coverage Requirements

| Metric | Minimum Threshold |
|--------|-------------------|
| Instruction coverage | **80%** |
| Branch coverage | **60%** |

### What MUST Be Tested

Every production class with **behaviour** (methods beyond getters/constructors) requires a dedicated test:

| Class Type | Test Required? | Notes |
|------------|----------------|-------|
| Services, Controllers | ‚úÖ **Yes** | Always requires `*Test.java` |
| Spring `@Component` / `@EventListener` | ‚úÖ **Yes** | Including lifecycle beans like `DataInitializer` |
| Utility classes | ‚úÖ **Yes** | e.g., `TextChunker`, parsers, validators |
| Records with factory methods | ‚úÖ **Yes** | e.g., `RagResponse.success()`, `IngestionResult.failure()` |
| Simple DTOs / records (data only) | ‚ö†Ô∏è Indirect | Covered via tests of classes that use them |
| Enums | ‚ö†Ô∏è Indirect | Covered via tests of classes that use them |

### What Does NOT Need a Dedicated Test

- Simple records with only a canonical constructor (e.g., `BookContent(int id, String title, String text)`)
- Enums with no logic (e.g., `GuardResult`)
- `package-info.java` files
- Main application class (`GenaiApplication.main()`) - Spring Boot convention

### Detecting Orphan Classes (No Test)

Before committing, verify every new production class has coverage:

```bash
# List production classes
find src/main -name "*.java" | grep -v package-info | sort > /tmp/prod.txt

# List test classes  
find src/test -name "*Test.java" -o -name "*IT.java" | sort > /tmp/tests.txt

# Manual review: each service/controller/component in prod should have a test
```

## Recommended Workflow for a New Feature

1. **Write failing unit test first** (`*Test.java`)
   - Use mocks for dependencies
   - Express expected behaviour
   - **Include ALL classes** that will have behaviour: services, controllers, components, event listeners

2. **Implement production code**
   - Make the unit test pass
   - Keep implementation minimal
   - **One production class = one test class** (for classes with logic)

3. **Add integration test if needed** (`*IT.java`)
   - Only for features requiring real external systems
   - Verify end-to-end behaviour

4. **Check coverage before committing**
   - Run `./coverage.sh` or use Coverage Gutters
   - Ensure new code is covered at **80%+**
   - **Review for orphan classes** - new production code without tests

## Common TDD Violations to Avoid

| Anti-Pattern | Problem | Solution |
|-------------|---------|----------|
| "Big Bang" commits | Many classes added without tests for all | Commit one feature at a time with its tests |
| "Glue code doesn't need tests" | Components like `DataInitializer` are skipped | All `@Component`, `@EventListener` classes need tests |
| "It's just a record" | Records with factory methods are untested | Test factory methods and any non-trivial logic |
| "Integration tests cover it" | Unit tests skipped because E2E exists | Unit tests are required; integration tests are supplementary |
| Redundant classes | Copy-pasted classes that are never used | Remove unused code; don't commit dead code |

## Pre-Commit Checklist

Before committing any code change, verify:

- [ ] Every new production class with behaviour has a corresponding `*Test.java`
- [ ] Tests were written **before** the production code (TDD)
- [ ] Coverage is at **80%+** for new code
- [ ] No orphan/unused classes exist
- [ ] Commit is small and focused (ideally one feature)

STARTER_CHARACTER for generating tests = üîç
